<html>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
 <meta http-equiv="Content-Style-Type" content="text/css">
 <!-- <link rel="stylesheet" href="default.css" type="text/css"> -->
 <title>HiBaseのファイル形式</title>
</head>
<body>

<h1>HiBaseのファイル形式</h1>
<p>
以下の情報は不正確で非公式です。
</p>


<h2>*.conf ファイル</h2>
<p>
テキストファイル。
</p>


<h2>ファイル</h2>
<p>
以下の様なファイルがあるとする。
</p>

<pre>
@DDD.dat
@DDD.idx
@Value.dat
@Value.idx
@f001.dat
@f001.idx
@f011.dat
@f011.idx
@f021.dat
@f021.idx
</pre>

<pre>
これらは、
@DDD.{dat,idx} : データベース管理情報、スキーマ
@Value.{dat,idx}: マルチメディアデータを格納するファイル
@f001.{dat,idx}: DBファイル番号 1 のファイル
@f011.{dat,idx}: DBファイル番号 11 のファイル
@f021.{dat,idx}: DBファイル番号 21 のファイル
</pre>

<h2>ヘッダ</h2>
<pre>
インデックスファイルとデータファイルはヘッダのサイズは512(0x200)byteと等しく
見た感じも似ています。

@f001.dat のヘッダを以下に示します。

0x00000000: 44 41 01 20 00 01 00 00 - 00 00 00 00 00 00 00 00 DA. ............
0x00000010: 07 d0 00 0a 00 10 00 15 - 00 13 00 12 00 00 00 00 ................
0x00000020: 07 d0 00 0a 00 10 00 17 - 00 18 00 01 00 00 00 00 ................
0x00000030: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................

どうやら、4byte目の 0x20 がこの @f001.dat のブロックサイズを表します。
第4byteが 0x20 の時のブロックサイズは 0x4000(16384)byte でしょう。
</pre>

<table border=1>
<tr><td>第4byte</td><td>ブロックサイズ</td></tr>
<tr><td>04</td><td>2048(0x800)byte</td></tr>
<tr><td>08</td><td>4096(0x1000)byte</td></tr>
<tr><td>10</td><td>8192(0x2000)byte</td></tr>
<tr><td>20</td><td>16384(0x4000)byte</td></tr>
</table>

<pre>
ブロックサイズは @DDD.dat からも取り出せますが、こちらは信用できません。
</pre>



<h2>データファイル(*.dat)</h2>

<pre>
まず、512 (0x200) byte ヘッダ
その後はたいてい 4096 (0x1000) byte のブロックの連続。
0, 2046, 4092, 6138, 8184, ... 2046n 番ブロックは 0xf0 で始まる0xf0ブロック。
それ以外は 0x10 で始まる0x10ブロック。
</pre>

<p>
では、@f001.dat を見てみます。
@f001.dat はどうやら1ブロックは16384(0x4000)byte のようなので、
f001d ディレクトリを作成し、512byteのヘッダをスキップした残りの @f0011.dat を
16384byteに分割し、ファイル名を y0000, y0001, ... にします。
</p>

<pre>
$ mkdir f001d
$ cd f001d
$ dd bs=512 skip=1 if=../@f001.dat | split -b 16384 -a 4
20096+0 records in
20096+0 records out
10289152 bytes transferred in 0.475979 seconds (21616819 bytes/sec)
$ j=0;for i in x*;do mv $i y$(printf "%04d" $j);j=$(($j+1));done
</pre>

<h2>0xf0 ブロック</h2>
<pre>
それでは、始めの 0番目のブロック、y0000 を見てみます。 

0x00000000: f0 00 00 00 f0 00 10 00 - 10 00 10 00 10 00 10 01 ................
0x00000010: 10 01 10 00 10 00 10 00 - 10 00 10 00 10 01 10 00 ................
0x00000020: 10 02 10 00 10 00 10 02 - 10 00 10 00 10 02 10 00 ................

はじめのバイトから見ていきます。

f0
始めの 0xf0 はこのブロックが0xf0ブロックであることを示します。

00 00 00 f0 00 
その後の 5byte は不明。

ここからは2byteづつ、続くブロックの1ブロック分の何かの情報です。
ブロックの空き容量と関係しているみたいです。

10 00  10 00  10 00  10 00  10 01  10 01  10 00  10 00  10 00  10 00  10 00  10 01 
つまり、第1ブロックが 0x10 0x00、第2ブロックが 0x10 0x00、となります。

この2byteが 0xff 0xff のブロックは存在しないことを意味します。

ブロックサイズ 0x4000 byte のうち始めの6byte 以降 2byte づつなので、
(0x4000 - 6) / 2 = 8189 で 8189 ブロック分のデータが格納できます。

ちなみに、たいていは1ブロックは 4096 (0x1000) byteなので、
(0x1000 - 6) / 2 = 2045で 2045ブロック分となります。
よって、2046の倍数のブロックが 0xf0 ブロックとなるようです。

y0000 に戻りまして、

0x000004e0: 10 00 10 00 10 02 10 01 - 10 02 11 f9 ff ff ff ff ................
0x000004f0: ff ff ff ff ff ff ff ff - ff ff ff ff ff ff ff ff ................

これより
第622ブロック 10 00
第623ブロック 10 00
第624ブロック 10 02
第625ブロック 10 01
第626ブロック 10 02
第627ブロック 11 f9
第628ブロック ff ff

となり、第628ブロック以降は存在しないことになります。
</pre>

<h2>0x10ブロック</h2>
<pre>
y0001 を見てみます。

0x00000000: 10 00 3f fc 00 00 01 00 - 24 01 07 01 31 02 06 0a ..?.....$...1...
0x00000010: 30 30 30 31 30 30 30 31 - 30 30 03 06 02 82 a0 04 0001000100...あ.
0x00000020: 06 02 82 a0 11 06 06 31 - 32 30 39 30 31 00 00 02 ..あ...120901...
0x00000030: 00 66 01 07 01 32 02 06 - 0a 30 30 30 31 30 30 30 .f...2...0001000
0x00000040: 32 30 30 03 06 12 82 a0 - 81 54 8b ca 94 74 82 c9 200...あゝ玉杯に
0x00000050: 89 d4 82 a4 82 af 82 c4 - 04 06 1a 82 a0 82 a0 82 花うけて...ああぎ
0x00000060: ac 82 e5 82 ad 82 cd 82 - a2 82 c9 82 cd 82 c8 82 .ょくはいにはなう
0x00000070: a4 82 af 82 c4 0e 50 17 - 00 00 01 00 00 00 5a 00 .けて.........Z.
0x00000080: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 11 ................

10 00 
まず、0x10 がこのブロックが0x10ブロックであることを示します。0x00 は不明。

3f fc 
ビッグエンディアンでブロック内の使用バイト数。 0x3ffc = 16380。
0x3ffc + 4 = 0x4000 であり、@f001.datはブロックサイズが0x4000なのでいっぱい。

つぎからがレコードです。レコード番号1から3までが続いているのでそれらを
適当に改行して示します。

00 00 01 
00 24 
01 07 01 31 
02 06 0a 30 30 30 31 30 30 30 31 30 30 
03 06 02 82 a0 
04 06 02 82 a0 
11 06 06 31 32 30 39 30 31 

00 00 02 
00 66 
01 07 01 32 
02 06 0a 30 30 30 31 30 30 30 32 30 30 
03 06 12 82 a0 81 54 8b ca 94 74 82 c9 89 d4 82 a4 82 af 82 c4 
04 06 1a 82 a0 82 a0 82 ac 82 e5 82 ad 82 cd 82 a2 82 c9 82 cd 82 c8 82 a4 82 af 82 c4 
0e 50 17 00 00 01 00 00 00 5a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
11 06 06 31 35 31 34 30 31 

00 00 03 
00 54 
01 07 01 33 
02 06 0a 30 30 30 31 30 30 30 33 30 30 
03 06 0a 82 a0 81 54 96 ec 94 9e 93 bb 
04 06 10 82 a0 82 a0 82 cc 82 de 82 ac 82 c6 82 a4 82 b0 
0e 50 17 00 00 02 00 00 00 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
11 06 06 31 35 30 36 30 31 

これらは以下のようなデータです。

record: 1
001 001: 1
002 001: 0001000100
003 001: あ
004 001: あ
017 001: 120901

record: 2
001 001: 2
002 001: 0001000200
003 001: あゝ玉杯に花うけて
004 001: ああぎょくはいにはなうけて
014 001: 【本】『佐藤紅緑全集　上』（1967・講談社）　▽加藤謙一著『少年倶楽部時代』（1968・講談社）
017 001: 151401

record: 3
001 001: 3
002 001: 0001000300
003 001: あゝ野麦峠
004 001: ああのむぎとうげ
014 001: 【本】『あゝ野麦峠』（角川文庫）
017 001: 150601


レコード番号1をまた示します。

00 00 01 
00 24 
01 07 01 31 
02 06 0a 30 30 30 31 30 30 30 31 30 30 
03 06 02 82 a0 
04 06 02 82 a0 
11 06 06 31 32 30 39 30 31 

00 00 01 
まず最初の3byteはレコード番号です。0x000001 = 1

00 24 
レコードのバイト長。0x0024 = 36。以降 36byteがレコード番号1のデータ

01 07 01 31 
0x01 が項目番号 0x01 = 1。
0x07 は文字列のデータ型。
0x01 は文字列のbyte長 0x01 = 1
0x31 は文字列(sjis)。 "1"

02 06 0a 30 30 30 31 30 30 30 31 30 30 
0x02 が項目番号 0x02 = 2。
0x06 は文字列のデータ型。
0x0a は文字列のbyte長 0x0a = 10
30 30 30 31 30 30 30 31 30 30 は文字列(sjis)。 "0001000100"

03 06 02 82 a0 
0x03 が項目番号 0x03 = 3。
0x06 は文字列のデータ型。
0x02 は文字列のbyte長 0x02 = 2
82 a0 は文字列(sjis)。"あ"

以下同様。

</pre>

<h3>マルチメディアデータ</h3>

<pre>
256byte以上のデータは @f[0-9]*.dat には格納できず、
分割して、@Value.dat に格納します。
それをマルチメディアデータと呼びます。

分割サイズは3584(0xe00)byteで固定だろうか?
もしも、8の倍数以外で分割されると、暗号の復号に影響が出るんだけど。

上の例ではレコード番号2の項目番号14はマルチメディアデータ。

マルチメディアデータは @Value.{dat,idx} に格納されるためその ID とbyte長が入ってます。

0e 50 17 00 00 01 00 00 00 5a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 

0x0e が項目番号 0x0e = 14。
0x50 はマルチメディアデータのテキスト型。
0x17 項目のバイト長。0x17 = 23

00 00 01 
マルチメディアデータのID。0x000001 = 1。

00 00 00 5a 
そのマルチメディアデータのサイズ。0x0000005a = 90。

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
不明。
</pre>

<h3>マルチバリュー</h3>
<pre>
一つの項目に複数の値を格納する機能。
データ型が0xffでマルチバリュー。
例えば、

01 ff 02 00 07 01 31 07 01 30

0x01 項目番号
0xff マルチバリュー
0x02 マルチバリューの値の数 0x02 = 2
0x00 不明

07 01 31
続いて、マルチバリューの1つめ。

07 01 30
マルチバリューの2つめ。

</pre>

<h2>インデックスファイル (*.idx)</h2>
<pre>
512byte (0x200) byte のヘッダ。
その後はブロックの連続。
ブロックサイズはヘッダにある。たいていは 2048byte (0x800) byte。
</pre>

<h3>0x0fブロック</h3>
<pre>
第0ブロックは0x0fブロック。

0x00000000: 0f 00 00 00 ff ff ff ff - ff ff ff ff ff ff ff ff ................
0x00000010: ff ff ff ff ff ff ff ff - ff ff ff ff ff ff ff ff ................

第5byte目以降、各ビットが各ブロックが使用か未使用かを表す。

</pre>

<h3>0x01ブロック</h3>
<pre>
第1ブロックは0x01ブロックだろう。

0x00000000: 01 00 00 00 00 00 02 01 - a4 de 01 a4 de 00 00 00 ........ま.ま...
0x00000010: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x00000020: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x00000030: 00 00 00 00 00 00 03 06 - 00 00 00 00 00 00 04 06 ................
0x00000040: 00 00 05 20 00 00 06 06 - 00 00 07 20 00 00 08 06 ... ....... ....
0x00000050: 00 00 09 20 00 00 0a 06 - 00 00 0b 20 00 00 0c 06 ... ....... ....
0x00000060: 00 00 0d 20 00 00 0e 06 - 00 00 0f 20 00 00 00 00 ... ....... ....
0x00000070: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x00000080: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x00000090: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00 ................
0x000000a0: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 10 06 ................

第8-10byte
01 a4 de
最大のレコード番号。0x01a4de=107742。

01 a4 de
総レコード数。0x01a4de=107742。

第45byte以降はキー項目のB木のルートのブロック番号とその型。

00 00 00 00  00 00 00 00  
第1項目はなし

00 00 03 06  00 00 00 00
第2項目は 0x000003=3ブロックにルート。型は0x06

00 00 04 06  00 00 05 20
第3項目は 0x000004=4ブロックに。
0x000005=5ブロックには後方一致検索用(0x20)のルート。

00 00 10 06  00 00 00 00 
第17項目は 0x000010=16ブロックに。
</pre>

<h3>0x03ブロック</h3>
<pre>
レコード番号からデータファイル内のブロック番号へのテーブル
</pre>

<h4>0x03 0x01ブロック</h4>
<pre>
y0002より、
このブロックは、
レコード番号からデータファイル内のブロック番号へのテーブルではなく、
インデックスファイル内の0x03ブロックへのテーブル。
このようなブロックを 0x03 0x01 ブロックと呼ぶ。

0x00000000: 03 01 00 f0 00 00 51 00 - 00 52 00 00 96 00 00 d9 ......Q..R......
0x00000010: 00 01 18 00 01 59 00 01 - 96 00 01 d7 00 02 16 00 .....Y..........
0x00000020: 02 17 00 02 86 00 02 87 - 00 03 05 00 03 06 00 03 ................

03 01
このブロックが 0x03 0x01 ブロックであることを表す。

00 f0
ブロック内の使用byte数

これ以降は3byteずつブロック番号。
00 00 51
0x000051=81
</pre>

<h4>0x03 0x00ブロック</h4>
<pre>
y0081

0x00000000: 03 00 0f fc 00 00 00 00 - 00 01 00 00 01 00 00 01 ................
0x00000010: 00 00 01 00 00 01 00 00 - 01 00 00 01 00 00 01 00 ................
0x00000020: 00 01 00 00 01 00 00 01 - 00 00 01 00 00 01 00 00 ................

03 00
このブロックが 0x03 0x01 ブロックであることを表す。

0f fc
ブロック内の使用byte数

これ以降は3byteずつブロック番号。

00 00 00
レコード番号0のブロック番号 0x000000=0。
レコード番号0は存在しないと思う。

00 00 01
レコード番号1のブロック番号が0x000001=1。
</pre>

<h3>0x07ブロック</h3>
<pre>
B木の葉。項目値からレコード番号。

y0018 より、

0x00000000: 07 03 08 94 09 31 30 34 - 94 d4 8c b3 91 66 00 01 .....104番元素..
0x00000010: 01 3e 29 0a 32 31 83 5a - 83 93 83 60 94 67 00 01 .>).21センチ波..
0x00000020: 01 1a 8c 09 34 82 67 83 - 4e 83 89 83 75 00 01 01 ....4Ｈクラブ...

07
このブロックが0x07ブロック

03
項目番号0x03=3の

08 94
ブロック内の使用byte数 0x0894(2196)byte。
ブロックの後ろにゴミが残っているので重要。

09 31 30 34 94 d4 8c b3 91 66
長さ 0x09の文字列

00 01
レコード数

01 3e 29
レコード番号


</pre>

<h3>0x05ブロック, 0x06ブロック</h3>
<pre>
B木のノード。項目値から0x07, 0x06ブロック番号。
</pre>

<h3></h3>
<pre>
</pre>


<h2>不明なこと</h2>
<pre>

</pre>

</body>
</html>
