<html>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
 <meta http-equiv="Content-Style-Type" content="text/css">
 <!-- <link rel="stylesheet" href="default.css" type="text/css"> -->
 <title>HiBaseのファイル形式</title>
</head>
<body>

<h1>HiBaseのファイル形式</h1>
<p>
以下の情報は非正確で非公式です。
</p>


<h2>*.conf ファイル</h2>
<p>
テキストファイル。
</p>


<h2>ファイル</h2>
<p>
以下の様なファイルがあるとする。
</p>

<pre>
@DDD.dat
@DDD.idx
@Value.dat
@Value.idx
@f001.dat
@f001.idx
@f011.dat
@f011.idx
@f021.dat
@f021.idx
</pre>

<pre>
これらは、
@DDD.{dat.idx} : データベース管理情報、スキーマ
@Value.{dat.idx}: マルチメディアデータを格納するファイル
@f001.{dat.idx}: DBファイル番号 1 のファイル
@f011.{dat.idx}: DBファイル番号 11 のファイル
@f021.{dat.idx}: DBファイル番号 21 のファイル
</pre>

<h2>*.idx ファイル</h2>
<pre>
*.dat のキーとレコード番号のB木らしい。
512byte (0x200) byte のヘッダ。内容は不明
その後はたいてい 2048byte (0x800) byte のブロックの連続。
</pre>

<h2>*.dat ファイル</h2>

<pre>
まず、512 (0x200) byte ヘッダ
その後はたいてい 4096 (0x1000) byte のブロックの連続。
0, 2046, 4092, 6138, 8184, ... 2046n 番ブロックは 0xf0 で始まる0xf0ブロック。
それ以外は 0x10 で始まる0x10ブロック。
</pre>

<p>
では、@f001.dat を見てみます。
@f001.dat はどうやら1ブロックは16384(0x4000)byte のようなので、
f001d ディレクトリを作成し、512byteのヘッダをスキップした残りの @f0011.dat を
16384byteに分割し、ファイル名を y0000, y0001, ... にします。
</p>

<pre>
$ mkdir f001d
$ cd f001d
$ dd bs=512 skip=1 if=../@f001.dat | split -b 16384 -a 4
20096+0 records in
20096+0 records out
10289152 bytes transferred in 0.475979 seconds (21616819 bytes/sec)
$ j=0;for i in x*;do mv $i y$(printf "%04d" $j);j=$(($j+1));done
</pre>

<h2>0xf0 ブロック</h2>
<pre>
それでは、始めの 0番目のブロック、y0000 を見てみます。 

0x00000000: f0 00 00 00 f0 00 10 00 - 10 00 10 00 10 00 10 01 ................
0x00000010: 10 01 10 00 10 00 10 00 - 10 00 10 00 10 01 10 00 ................
0x00000020: 10 02 10 00 10 00 10 02 - 10 00 10 00 10 02 10 00 ................

はじめのバイトから見ていきます。

f0
始めの 0xf0 はこのブロックが0xf0ブロックであることを示します。

00 00 00 f0 00 
その後の 5byte は不明。

ここからは2byteづつ、続くブロックの1ブロック分の何かの情報です。
10 00  10 00  10 00  10 00  10 01  10 01  10 00  10 00  10 00  10 00  10 00  10 01 
つまり、第1ブロックが 0x10 0x00、第2ブロックが 0x10 0x00、となります。

この2byteが 0xff 0xff のブロックは存在しないことを意味します。

ブロックサイズ 0x4000 byte のうち始めの6byte 以降 2byte づつなので、
(0x4000 - 6) / 2 = 8189 で 8189 ブロック分のデータが格納できます。

ちなみに、たいていは1ブロックは 4096 (0x1000) byteなので、
(0x1000 - 6) / 2 = 2045で 2045ブロック分となります。
よって、2046の倍数のブロックが 0xf0 ブロックとなるようです。

y0000 に戻りまして、

0x000004e0: 10 00 10 00 10 02 10 01 - 10 02 11 f9 ff ff ff ff ................
0x000004f0: ff ff ff ff ff ff ff ff - ff ff ff ff ff ff ff ff ................

これより
第622ブロック 10 00
第623ブロック 10 00
第624ブロック 10 02
第625ブロック 10 01
第626ブロック 10 02
第627ブロック 11 f9
第628ブロック ff ff

となり、第628ブロック以降は存在しないことになります。
</pre>

<h2>0x10ブロック</h2>
<pre>
y0001 を見てみます。

0x00000000: 10 00 3f fc 00 00 01 00 - 24 01 07 01 31 02 06 0a ..?.....$...1...
0x00000010: 30 30 30 31 30 30 30 31 - 30 30 03 06 02 82 a0 04 0001000100...あ.
0x00000020: 06 02 82 a0 11 06 06 31 - 32 30 39 30 31 00 00 02 ..あ...120901...
0x00000030: 00 66 01 07 01 32 02 06 - 0a 30 30 30 31 30 30 30 .f...2...0001000
0x00000040: 32 30 30 03 06 12 82 a0 - 81 54 8b ca 94 74 82 c9 200...あゝ玉杯に
0x00000050: 89 d4 82 a4 82 af 82 c4 - 04 06 1a 82 a0 82 a0 82 花うけて...ああぎ
0x00000060: ac 82 e5 82 ad 82 cd 82 - a2 82 c9 82 cd 82 c8 82 .ょくはいにはなう
0x00000070: a4 82 af 82 c4 0e 50 17 - 00 00 01 00 00 00 5a 00 .けて.........Z.
0x00000080: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 11 ................

10 00 
まず、0x10 がこのブロックが0x10ブロック。0x00 は不明。

3f fc 
ビッグエンディアンでブロック内の使用バイト数。 0x3ffc = 16380。
@f001.datはブロックサイズが0x4000なのでほぼいっぱい。

つぎからがレコードです。レコード番号1から3までが続いているのでそれらを
適当に改行して示します。

00 00 01 
00 24 
01 07 01 31 
02 06 0a 30 30 30 31 30 30 30 31 30 30 
03 06 02 82 a0 
04 06 02 82 a0 
11 06 06 31 32 30 39 30 31 

00 00 02 
00 66 
01 07 01 32 
02 06 0a 30 30 30 31 30 30 30 32 30 30 
03 06 12 82 a0 81 54 8b ca 94 74 82 c9 89 d4 82 a4 82 af 82 c4 
04 06 1a 82 a0 82 a0 82 ac 82 e5 82 ad 82 cd 82 a2 82 c9 82 cd 82 c8 82 a4 82 af 82 c4 
0e 50 17 00 00 01 00 00 00 5a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
11 06 06 31 35 31 34 30 31 

00 00 03 
00 54 
01 07 01 33 
02 06 0a 30 30 30 31 30 30 30 33 30 30 
03 06 0a 82 a0 81 54 96 ec 94 9e 93 bb 
04 06 10 82 a0 82 a0 82 cc 82 de 82 ac 82 c6 82 a4 82 b0 
0e 50 17 00 00 02 00 00 00 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
11 06 06 31 35 30 36 30 31 

これらは以下のようなデータです。

record: 1
001 001: 1
002 001: 0001000100
003 001: あ
004 001: あ
017 001: 120901

record: 2
001 001: 2
002 001: 0001000200
003 001: あゝ玉杯に花うけて
004 001: ああぎょくはいにはなうけて
014 001: 【本】『佐藤紅緑全集　上』（1967・講談社）　▽加藤謙一著『少年倶楽部時代』（1968・講談社）
017 001: 151401

record: 3
001 001: 3
002 001: 0001000300
003 001: あゝ野麦峠
004 001: ああのむぎとうげ
014 001: 【本】『あゝ野麦峠』（角川文庫）
017 001: 150601


レコード番号1をまた示します。

00 00 01 
00 24 
01 07 01 31 
02 06 0a 30 30 30 31 30 30 30 31 30 30 
03 06 02 82 a0 
04 06 02 82 a0 
11 06 06 31 32 30 39 30 31 

00 00 01 
まず最初の3byteはレコード番号です。0x000001 = 1

00 24 
レコードのバイト長。0x0024 = 36。以降 36byteがレコード番号1のデータ

01 07 01 31 
0x01 が項目番号 0x01 = 1。
0x07 は文字列のデータ型。
0x01 は文字列のbyte長 0x01 = 1
0x31 は文字列(sjis)。 "1"

02 06 0a 30 30 30 31 30 30 30 31 30 30 
0x02 が項目番号 0x02 = 2。
0x06 は文字列のデータ型。
0x0a は文字列のbyte長 0x0a = 10
30 30 30 31 30 30 30 31 30 30 は文字列(sjis)。 "0001000100"

03 06 02 82 a0 
0x03 が項目番号 0x03 = 3。
0x06 は文字列のデータ型。
0x02 は文字列のbyte長 0x02 = 2
82 a0 は文字列(sjis)。"あ"

以下同様。

</pre>

<h3>マルチメディアデータ</h3>

<pre>
256byte以上のデータは @f[0-9]*.dat には格納できず、
分割して、@Value.dat に格納します。
それをマルチメディアデータと呼びます。

上の例ではレコード番号2の項目番号14はマルチメディアデータ。

マルチメディアデータは @Value.{dat,idx} に格納されるためその ID とbyte長が入ってます。

0e 50 17 00 00 01 00 00 00 5a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 

0x0e が項目番号 0x0e = 14。
0x50 はマルチメディアデータのテキスト型。
0x17 項目のバイト長。0x17 = 23

00 00 01 
マルチメディアデータのID。0x000001 = 1。

00 00 00 5a 
そのマルチメディアデータのサイズ。0x0000005a = 90。

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
不明。
</pre>

<h3>マルチバリュー</h3>
<pre>
一つの項目に複数の値を格納する機能。
データ型が0xffでマルチバリュー。
例えば、

01 ff 02 00 07 01 31 07 01 30

0x01 項目番号
0xff マルチバリュー
0x02 マルチバリューの値の数 0x02 = 2
0x00 不明

07 01 31
続いて、マルチバリューの1つめ。

07 01 30
マルチバリューの2つめ。

</pre>

<h2>不明なこと</h2>
<pre>
*.idx ファイル
レコード番号からブロック番号へのテーブル
0x200byteのヘッダ
</pre>

</body>
</html>
